{"ast":null,"code":"import MaskedPattern from './pattern.js';\nimport '../core/change-details.js';\nimport { normalizePrepare } from '../core/utils.js';\nimport IMask from '../core/holder.js';\nimport '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/input-definition.js';\nimport './factory.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './regexp.js';\n\n/** Pattern which accepts ranges */\nclass MaskedRange extends MaskedPattern {\n  /**\n    Optionally sets max length of pattern.\n    Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\n  */\n\n  /** Min bound */\n\n  /** Max bound */\n\n  /** */\n\n  get _matchFrom() {\n    return this.maxLength - String(this.from).length;\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    // TODO type\n    opts = Object.assign({\n      to: this.to || 0,\n      from: this.from || 0,\n      maxLength: this.maxLength || 0\n    }, opts);\n    let maxLength = String(opts.to).length;\n    if (opts.maxLength != null) maxLength = Math.max(maxLength, opts.maxLength);\n    opts.maxLength = maxLength;\n    const fromStr = String(opts.from).padStart(maxLength, '0');\n    const toStr = String(opts.to).padStart(maxLength, '0');\n    let sameCharsCount = 0;\n    while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;\n    opts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\\\0') + '0'.repeat(maxLength - sameCharsCount);\n    super._update(opts);\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    return super.isComplete && Boolean(this.value);\n  }\n  boundaries(str) {\n    let minstr = '';\n    let maxstr = '';\n    const [, placeholder, num] = str.match(/^(\\D*)(\\d*)(\\D*)/) || [];\n    if (num) {\n      minstr = '0'.repeat(placeholder.length) + num;\n      maxstr = '9'.repeat(placeholder.length) + num;\n    }\n    minstr = minstr.padEnd(this.maxLength, '0');\n    maxstr = maxstr.padEnd(this.maxLength, '9');\n    return [minstr, maxstr];\n  }\n\n  // TODO str is a single char everytime\n  /**\n    @override\n  */\n  doPrepare(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let details;\n    [ch, details] = normalizePrepare(super.doPrepare(ch.replace(/\\D/g, ''), flags));\n    if (!this.autofix || !ch) return ch;\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    let nextVal = this.value + ch;\n    if (nextVal.length > this.maxLength) return '';\n    const [minstr, maxstr] = this.boundaries(nextVal);\n    if (Number(maxstr) < this.from) return fromStr[nextVal.length - 1];\n    if (Number(minstr) > this.to) {\n      if (this.autofix === 'pad' && nextVal.length < this.maxLength) {\n        return ['', details.aggregate(this.append(fromStr[nextVal.length - 1] + ch, flags))];\n      }\n      return toStr[nextVal.length - 1];\n    }\n    return ch;\n  }\n\n  /**\n    @override\n  */\n  doValidate() {\n    const str = this.value;\n    const firstNonZero = str.search(/[^0]/);\n    if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n    const [minstr, maxstr] = this.boundaries(str);\n    return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(...arguments);\n  }\n}\nIMask.MaskedRange = MaskedRange;\nexport { MaskedRange as default };","map":{"version":3,"names":["MaskedPattern","normalizePrepare","IMask","MaskedRange","_matchFrom","maxLength","String","from","length","_update","opts","Object","assign","to","Math","max","fromStr","padStart","toStr","sameCharsCount","mask","slice","replace","repeat","isComplete","Boolean","value","boundaries","str","minstr","maxstr","placeholder","num","match","padEnd","doPrepare","ch","flags","arguments","undefined","details","autofix","nextVal","Number","aggregate","append","doValidate","firstNonZero","search","default"],"sources":["C:/Users/Antony/Documents/GitHub/vinki/client/node_modules/imask/esm/masked/range.js"],"sourcesContent":["import MaskedPattern from './pattern.js';\nimport '../core/change-details.js';\nimport { normalizePrepare } from '../core/utils.js';\nimport IMask from '../core/holder.js';\nimport '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/input-definition.js';\nimport './factory.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './regexp.js';\n\n/** Pattern which accepts ranges */\nclass MaskedRange extends MaskedPattern {\n  /**\n    Optionally sets max length of pattern.\n    Used when pattern length is longer then `to` param length. Pads zeros at start in this case.\n  */\n\n  /** Min bound */\n\n  /** Max bound */\n\n  /** */\n\n  get _matchFrom() {\n    return this.maxLength - String(this.from).length;\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    // TODO type\n    opts = Object.assign({\n      to: this.to || 0,\n      from: this.from || 0,\n      maxLength: this.maxLength || 0\n    }, opts);\n    let maxLength = String(opts.to).length;\n    if (opts.maxLength != null) maxLength = Math.max(maxLength, opts.maxLength);\n    opts.maxLength = maxLength;\n    const fromStr = String(opts.from).padStart(maxLength, '0');\n    const toStr = String(opts.to).padStart(maxLength, '0');\n    let sameCharsCount = 0;\n    while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;\n    opts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, '\\\\0') + '0'.repeat(maxLength - sameCharsCount);\n    super._update(opts);\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    return super.isComplete && Boolean(this.value);\n  }\n  boundaries(str) {\n    let minstr = '';\n    let maxstr = '';\n    const [, placeholder, num] = str.match(/^(\\D*)(\\d*)(\\D*)/) || [];\n    if (num) {\n      minstr = '0'.repeat(placeholder.length) + num;\n      maxstr = '9'.repeat(placeholder.length) + num;\n    }\n    minstr = minstr.padEnd(this.maxLength, '0');\n    maxstr = maxstr.padEnd(this.maxLength, '9');\n    return [minstr, maxstr];\n  }\n\n  // TODO str is a single char everytime\n  /**\n    @override\n  */\n  doPrepare(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let details;\n    [ch, details] = normalizePrepare(super.doPrepare(ch.replace(/\\D/g, ''), flags));\n    if (!this.autofix || !ch) return ch;\n    const fromStr = String(this.from).padStart(this.maxLength, '0');\n    const toStr = String(this.to).padStart(this.maxLength, '0');\n    let nextVal = this.value + ch;\n    if (nextVal.length > this.maxLength) return '';\n    const [minstr, maxstr] = this.boundaries(nextVal);\n    if (Number(maxstr) < this.from) return fromStr[nextVal.length - 1];\n    if (Number(minstr) > this.to) {\n      if (this.autofix === 'pad' && nextVal.length < this.maxLength) {\n        return ['', details.aggregate(this.append(fromStr[nextVal.length - 1] + ch, flags))];\n      }\n      return toStr[nextVal.length - 1];\n    }\n    return ch;\n  }\n\n  /**\n    @override\n  */\n  doValidate() {\n    const str = this.value;\n    const firstNonZero = str.search(/[^0]/);\n    if (firstNonZero === -1 && str.length <= this._matchFrom) return true;\n    const [minstr, maxstr] = this.boundaries(str);\n    return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(...arguments);\n  }\n}\nIMask.MaskedRange = MaskedRange;\n\nexport { MaskedRange as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}