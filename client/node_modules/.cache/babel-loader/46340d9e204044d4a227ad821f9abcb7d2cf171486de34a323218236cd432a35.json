{"ast":null,"code":"import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\nconst _excluded = [\"_blocks\"];\n\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {string} opts.displayChar\n  @param {boolean} opts.lazy\n*/\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    super(Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n    @param {Object} opts\n  */\n  _update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n\n  /** */\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this._stops = [];\n    this._maskedBlocks = {};\n    let pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      var _defs$char, _defs$char2;\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          // $FlowFixMe no ideas\n          const maskedBlock = createMask(Object.assign({\n            parent: this,\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite\n          }, this.blocks[bName]));\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const maskOpts = (_defs$char = defs[char]) !== null && _defs$char !== void 0 && _defs$char.mask && !(((_defs$char2 = defs[char]) === null || _defs$char2 === void 0 ? void 0 : _defs$char2.mask.prototype) instanceof IMask.Masked) ? defs[char] : {\n        mask: defs[char]\n      };\n      const def = isInput ? new PatternInputDefinition(Object.assign({\n        parent: this,\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar\n      }, maskOpts)) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    return Object.assign({}, super.state, {\n      _blocks: this._blocks.map(b => b.state)\n    });\n  }\n  set state(state) {\n    const {\n        _blocks\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    return this._blocks.every(b => b.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    // TODO return _value when not in change?\n    return this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    super.value = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n\n  /**\n    @override\n  */\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n\n  /**\n    @override\n  */\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const blockIter = this._mapPosToBlock(this.value.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, Object.assign({}, flags, {\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n      }));\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.value.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        // $FlowFixMe `_blocks` may not be present\n        const args = b._blocks != null ? [b._blocks.length] : [];\n        const bDetails = b._appendPlaceholder(...args);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.value;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n\n  /** */\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.value.length, 0);\n  }\n\n  /** */\n  _forEachBlocksInRange(fromPos) {\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let fn = arguments.length > 2 ? arguments[2] : undefined;\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos(cursorPos) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.value.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n\n      // cursor.popState();\n      // if (\n      //   cursor.pushRightBeforeInput() &&\n      //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n      //   (!this.lazy || this.extractInput())\n      // ) return cursor.pos;\n\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.value.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n\n  /**\n    @override\n  */\n  totalInputPositions() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let total = 0;\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n    return total;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\nexport { MaskedPattern as default };","map":{"version":3,"names":["_","_objectWithoutPropertiesLoose","DIRECTION","ChangeDetails","Masked","PatternInputDefinition","DEFAULT_INPUT_DEFINITIONS","PatternFixedDefinition","ChunksTailDetails","PatternCursor","createMask","IMask","_excluded","MaskedPattern","constructor","opts","arguments","length","undefined","definitions","Object","assign","DEFAULTS","_update","_rebuildMask","defs","_blocks","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","i","_defs$char","_defs$char2","blocks","p","slice","bNames","keys","filter","bName","indexOf","sort","a","b","maskedBlock","parent","lazy","eager","placeholderChar","displayChar","overwrite","push","char","isInput","STOP_CHAR","ESCAPE_CHAR","maskOpts","prototype","def","isOptional","isUnmasking","state","map","maskedState","forEach","bi","reset","isComplete","every","isFilled","isFixed","doCommit","unmaskedValue","reduce","str","value","displayValue","appendTail","tail","aggregate","_appendPlaceholder","_appendEager","_this$_mapPosToBlock","details","startBlockIndex","_mapPosToBlock","index","d","inserted","_appendCharRaw","ch","flags","blockIter","_flags$_beforeTailSta","_flags$_beforeTailSta2","block","blockDetails","_appendChar","_beforeTailState","skip","rawInserted","extractTail","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","_blockStartPos","blockIndex","extend","extractInput","input","stopBefore","si","toBlockIndex","startBlockIter","endBlockIndex","args","bDetails","_value","pos","accVal","blockStartPos","offset","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","cursor","pushRightBeforeInput","popState","pushLeftBeforeInput","LEFT","FORCE_LEFT","pushRightBeforeFilled","ok","pushLeftBeforeRequired","pushLeftBeforeFilled","pushRightBeforeRequired","RIGHT","FORCE_RIGHT","totalInputPositions","total","name","maskedBlocks","indices","gi","InputDefinition","FixedDefinition","default"],"sources":["C:/Users/Antony/Documents/GitHub/vinki/client/node_modules/imask/esm/masked/pattern.js"],"sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\nimport PatternCursor from './pattern/cursor.js';\nimport createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport './regexp.js';\nimport '../core/continuous-tail-details.js';\n\nconst _excluded = [\"_blocks\"];\n\n/**\n  Pattern mask\n  @param {Object} opts\n  @param {Object} opts.blocks\n  @param {Object} opts.definitions\n  @param {string} opts.placeholderChar\n  @param {string} opts.displayChar\n  @param {boolean} opts.lazy\n*/\nclass MaskedPattern extends Masked {\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Single char for filled input */\n\n  /** Show placeholder only when needed */\n\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    super(Object.assign({}, MaskedPattern.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n    @param {Object} opts\n  */\n  _update() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n    super._update(opts);\n    this._rebuildMask();\n  }\n\n  /** */\n  _rebuildMask() {\n    const defs = this.definitions;\n    this._blocks = [];\n    this._stops = [];\n    this._maskedBlocks = {};\n    let pattern = this.mask;\n    if (!pattern || !defs) return;\n    let unmaskingBlock = false;\n    let optionalBlock = false;\n    for (let i = 0; i < pattern.length; ++i) {\n      var _defs$char, _defs$char2;\n      if (this.blocks) {\n        const p = pattern.slice(i);\n        const bNames = Object.keys(this.blocks).filter(bName => p.indexOf(bName) === 0);\n        // order by key length\n        bNames.sort((a, b) => b.length - a.length);\n        // use block name with max length\n        const bName = bNames[0];\n        if (bName) {\n          // $FlowFixMe no ideas\n          const maskedBlock = createMask(Object.assign({\n            parent: this,\n            lazy: this.lazy,\n            eager: this.eager,\n            placeholderChar: this.placeholderChar,\n            displayChar: this.displayChar,\n            overwrite: this.overwrite\n          }, this.blocks[bName]));\n          if (maskedBlock) {\n            this._blocks.push(maskedBlock);\n\n            // store block index\n            if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];\n            this._maskedBlocks[bName].push(this._blocks.length - 1);\n          }\n          i += bName.length - 1;\n          continue;\n        }\n      }\n      let char = pattern[i];\n      let isInput = (char in defs);\n      if (char === MaskedPattern.STOP_CHAR) {\n        this._stops.push(this._blocks.length);\n        continue;\n      }\n      if (char === '{' || char === '}') {\n        unmaskingBlock = !unmaskingBlock;\n        continue;\n      }\n      if (char === '[' || char === ']') {\n        optionalBlock = !optionalBlock;\n        continue;\n      }\n      if (char === MaskedPattern.ESCAPE_CHAR) {\n        ++i;\n        char = pattern[i];\n        if (!char) break;\n        isInput = false;\n      }\n      const maskOpts = (_defs$char = defs[char]) !== null && _defs$char !== void 0 && _defs$char.mask && !(((_defs$char2 = defs[char]) === null || _defs$char2 === void 0 ? void 0 : _defs$char2.mask.prototype) instanceof IMask.Masked) ? defs[char] : {\n        mask: defs[char]\n      };\n      const def = isInput ? new PatternInputDefinition(Object.assign({\n        parent: this,\n        isOptional: optionalBlock,\n        lazy: this.lazy,\n        eager: this.eager,\n        placeholderChar: this.placeholderChar,\n        displayChar: this.displayChar\n      }, maskOpts)) : new PatternFixedDefinition({\n        char,\n        eager: this.eager,\n        isUnmasking: unmaskingBlock\n      });\n      this._blocks.push(def);\n    }\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    return Object.assign({}, super.state, {\n      _blocks: this._blocks.map(b => b.state)\n    });\n  }\n  set state(state) {\n    const {\n        _blocks\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this._blocks.forEach((b, bi) => b.state = _blocks[bi]);\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    super.reset();\n    this._blocks.forEach(b => b.reset());\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    return this._blocks.every(b => b.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    return this._blocks.every(b => b.isFilled);\n  }\n  get isFixed() {\n    return this._blocks.every(b => b.isFixed);\n  }\n  get isOptional() {\n    return this._blocks.every(b => b.isOptional);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    this._blocks.forEach(b => b.doCommit());\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this._blocks.reduce((str, b) => str += b.unmaskedValue, '');\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    // TODO return _value when not in change?\n    return this._blocks.reduce((str, b) => str += b.value, '');\n  }\n  set value(value) {\n    super.value = value;\n  }\n  get displayValue() {\n    return this._blocks.reduce((str, b) => str += b.displayValue, '');\n  }\n\n  /**\n    @override\n  */\n  appendTail(tail) {\n    return super.appendTail(tail).aggregate(this._appendPlaceholder());\n  }\n\n  /**\n    @override\n  */\n  _appendEager() {\n    var _this$_mapPosToBlock;\n    const details = new ChangeDetails();\n    let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.value.length)) === null || _this$_mapPosToBlock === void 0 ? void 0 : _this$_mapPosToBlock.index;\n    if (startBlockIndex == null) return details;\n\n    // TODO test if it works for nested pattern masks\n    if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;\n    for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {\n      const d = this._blocks[bi]._appendEager();\n      if (!d.inserted) break;\n      details.aggregate(d);\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const blockIter = this._mapPosToBlock(this.value.length);\n    const details = new ChangeDetails();\n    if (!blockIter) return details;\n    for (let bi = blockIter.index;; ++bi) {\n      var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n      const block = this._blocks[bi];\n      if (!block) break;\n      const blockDetails = block._appendChar(ch, Object.assign({}, flags, {\n        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2[bi]\n      }));\n      const skip = blockDetails.skip;\n      details.aggregate(blockDetails);\n      if (skip || blockDetails.rawInserted) break; // go next char\n    }\n\n    return details;\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const chunkTail = new ChunksTailDetails();\n    if (fromPos === toPos) return chunkTail;\n    this._forEachBlocksInRange(fromPos, toPos, (b, bi, bFromPos, bToPos) => {\n      const blockChunk = b.extractTail(bFromPos, bToPos);\n      blockChunk.stop = this._findStopBefore(bi);\n      blockChunk.from = this._blockStartPos(bi);\n      if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n      chunkTail.extend(blockChunk);\n    });\n    return chunkTail;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (fromPos === toPos) return '';\n    let input = '';\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, fromPos, toPos) => {\n      input += b.extractInput(fromPos, toPos, flags);\n    });\n    return input;\n  }\n  _findStopBefore(blockIndex) {\n    let stopBefore;\n    for (let si = 0; si < this._stops.length; ++si) {\n      const stop = this._stops[si];\n      if (stop <= blockIndex) stopBefore = stop;else break;\n    }\n    return stopBefore;\n  }\n\n  /** Appends placeholder depending on laziness */\n  _appendPlaceholder(toBlockIndex) {\n    const details = new ChangeDetails();\n    if (this.lazy && toBlockIndex == null) return details;\n    const startBlockIter = this._mapPosToBlock(this.value.length);\n    if (!startBlockIter) return details;\n    const startBlockIndex = startBlockIter.index;\n    const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n    this._blocks.slice(startBlockIndex, endBlockIndex).forEach(b => {\n      if (!b.lazy || toBlockIndex != null) {\n        // $FlowFixMe `_blocks` may not be present\n        const args = b._blocks != null ? [b._blocks.length] : [];\n        const bDetails = b._appendPlaceholder(...args);\n        this._value += bDetails.inserted;\n        details.aggregate(bDetails);\n      }\n    });\n    return details;\n  }\n\n  /** Finds block in pos */\n  _mapPosToBlock(pos) {\n    let accVal = '';\n    for (let bi = 0; bi < this._blocks.length; ++bi) {\n      const block = this._blocks[bi];\n      const blockStartPos = accVal.length;\n      accVal += block.value;\n      if (pos <= accVal.length) {\n        return {\n          index: bi,\n          offset: pos - blockStartPos\n        };\n      }\n    }\n  }\n\n  /** */\n  _blockStartPos(blockIndex) {\n    return this._blocks.slice(0, blockIndex).reduce((pos, b) => pos += b.value.length, 0);\n  }\n\n  /** */\n  _forEachBlocksInRange(fromPos) {\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let fn = arguments.length > 2 ? arguments[2] : undefined;\n    const fromBlockIter = this._mapPosToBlock(fromPos);\n    if (fromBlockIter) {\n      const toBlockIter = this._mapPosToBlock(toPos);\n      // process first block\n      const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n      const fromBlockStartPos = fromBlockIter.offset;\n      const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n      fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n      if (toBlockIter && !isSameBlock) {\n        // process intermediate blocks\n        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n          fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n        }\n\n        // process last block\n        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n      }\n    }\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    const removeDetails = super.remove(fromPos, toPos);\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      removeDetails.aggregate(b.remove(bFromPos, bToPos));\n    });\n    return removeDetails;\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos(cursorPos) {\n    let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n    if (!this._blocks.length) return 0;\n    const cursor = new PatternCursor(this, cursorPos);\n    if (direction === DIRECTION.NONE) {\n      // -------------------------------------------------\n      // NONE should only go out from fixed to the right!\n      // -------------------------------------------------\n      if (cursor.pushRightBeforeInput()) return cursor.pos;\n      cursor.popState();\n      if (cursor.pushLeftBeforeInput()) return cursor.pos;\n      return this.value.length;\n    }\n\n    // FORCE is only about a|* otherwise is 0\n    if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n      // try to break fast when *|a\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeFilled();\n        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;\n        cursor.popState();\n      }\n\n      // forward flow\n      cursor.pushLeftBeforeInput();\n      cursor.pushLeftBeforeRequired();\n      cursor.pushLeftBeforeFilled();\n\n      // backward flow\n      if (direction === DIRECTION.LEFT) {\n        cursor.pushRightBeforeInput();\n        cursor.pushRightBeforeRequired();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;\n        cursor.popState();\n      }\n      if (cursor.ok) return cursor.pos;\n      if (direction === DIRECTION.FORCE_LEFT) return 0;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n\n      // cursor.popState();\n      // if (\n      //   cursor.pushRightBeforeInput() &&\n      //   // TODO HACK for lazy if has aligned left inside fixed and has came to the start - use start position\n      //   (!this.lazy || this.extractInput())\n      // ) return cursor.pos;\n\n      return 0;\n    }\n    if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n      // forward flow\n      cursor.pushRightBeforeInput();\n      cursor.pushRightBeforeRequired();\n      if (cursor.pushRightBeforeFilled()) return cursor.pos;\n      if (direction === DIRECTION.FORCE_RIGHT) return this.value.length;\n\n      // backward flow\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      cursor.popState();\n      if (cursor.ok) return cursor.pos;\n      return this.nearestInputPos(cursorPos, DIRECTION.LEFT);\n    }\n    return cursorPos;\n  }\n\n  /**\n    @override\n  */\n  totalInputPositions() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let total = 0;\n    this._forEachBlocksInRange(fromPos, toPos, (b, _, bFromPos, bToPos) => {\n      total += b.totalInputPositions(bFromPos, bToPos);\n    });\n    return total;\n  }\n\n  /** Get block by name */\n  maskedBlock(name) {\n    return this.maskedBlocks(name)[0];\n  }\n\n  /** Get all blocks by name */\n  maskedBlocks(name) {\n    const indices = this._maskedBlocks[name];\n    if (!indices) return [];\n    return indices.map(gi => this._blocks[gi]);\n  }\n}\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\nIMask.MaskedPattern = MaskedPattern;\n\nexport { MaskedPattern as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}