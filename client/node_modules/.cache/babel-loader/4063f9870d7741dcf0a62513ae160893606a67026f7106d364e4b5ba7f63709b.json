{"ast":null,"code":"import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION, normalizePrepare, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\nconst _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"],\n  _excluded2 = [\"mask\"];\n/** Dynamic mask for choosing apropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    this.currentMask = null;\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => createMask(m)) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch() {\n    let appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ?\n    // $FlowFixMe - tired to fight with type system\n    flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask === null || prevMask === void 0 ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, Object.assign({}, flags), tail);\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n\n  /**\n   @override\n  */\n  _appendEager() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return Object.assign({}, flags, {\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    });\n  }\n\n  /**\n    @override\n  */\n  doDispatch(appended) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    return this.dispatch(appended, this, flags, tail);\n  }\n\n  /**\n    @override\n  */\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n\n  /**\n    @override\n  */\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let [s, details] = normalizePrepare(super.doPrepare(str, flags));\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = normalizePrepare(super.doPrepare(s, this.currentMaskFlags(flags)));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) === null || _this$currentMask === void 0 ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    return this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    super.value = value;\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.currentMask ? this.currentMask.typedValue : '';\n  }\n\n  // probably typedValue should not be used with dynamic\n  set typedValue(value) {\n    let unmaskedValue = String(value);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = value;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isFilled);\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(...arguments))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    var _this$currentMask4;\n    return Object.assign({}, super.state, {\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.state\n    });\n  }\n  set state(state) {\n    const {\n        compiledMasks,\n        currentMaskRef,\n        currentMask\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    return this.currentMask ? this.currentMask.extractInput(...arguments) : '';\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    return this.currentMask ? this.currentMask.extractTail(...arguments) : super.extractTail(...arguments);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos() {\n    return this.currentMask ? this.currentMask.nearestInputPos(...arguments) : super.nearestInputPos(...arguments);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : super.overwrite;\n  }\n  set overwrite(overwrite) {\n    console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : super.eager;\n  }\n  set eager(eager) {\n    console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : super.skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    if (this.isInitialized || skipInvalid !== Masked.DEFAULTS.skipInvalid) {\n      console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }\n\n  /**\n    @override\n  */\n  maskEquals(mask) {\n    return Array.isArray(mask) && this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const _mask$mi = mask[mi],\n        {\n          mask: oldMask\n        } = _mask$mi,\n        restOpts = _objectWithoutPropertiesLoose(_mask$mi, _excluded2);\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    });\n  }\n\n  /**\n    @override\n  */\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) === null || _this$currentMask5 === void 0 ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.value.length : m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\nexport { MaskedDynamic as default };","map":{"version":3,"names":["_","_objectWithoutPropertiesLoose","DIRECTION","normalizePrepare","objectIncludes","ChangeDetails","createMask","Masked","IMask","_excluded","_excluded2","MaskedDynamic","constructor","opts","Object","assign","DEFAULTS","currentMask","_update","compiledMasks","Array","isArray","mask","map","m","_appendCharRaw","ch","flags","arguments","length","undefined","details","_applyDispatch","aggregate","_appendChar","currentMaskFlags","appended","tail","prevValueBeforeTail","_beforeTailState","_value","value","inputValue","rawInputValue","insertValue","_rawInputValue","tailValue","slice","prevMask","prevMaskState","state","doDispatch","reset","d","append","raw","tailShift","inserted","_appendPlaceholder","_appendEager","appendTail","_flags$_beforeTailSta","_flags$_beforeTailSta2","currentMaskRef","dispatch","doValidate","doPrepare","str","s","currentDetails","_this$currentMask","forEach","unmaskedValue","typedValue","String","displayValue","isComplete","_this$currentMask2","Boolean","isFilled","_this$currentMask3","remove","_this$currentMask4","maskedState","mi","extractInput","extractTail","doCommit","nearestInputPos","overwrite","console","warn","eager","skipInvalid","isInitialized","maskEquals","every","_mask$mi","oldMask","restOpts","typedValueEquals","_this$currentMask5","masked","inputs","index","isCurrent","startInputPos","FORCE_LEFT","weight","totalInputPositions","Math","max","sort","i1","i2","default"],"sources":["C:/Users/Antony/Documents/GitHub/vinki/client/node_modules/imask/esm/masked/dynamic.js"],"sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport { DIRECTION, normalizePrepare, objectIncludes } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport createMask from './factory.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\nconst _excluded = [\"compiledMasks\", \"currentMaskRef\", \"currentMask\"],\n  _excluded2 = [\"mask\"];\n/** Dynamic mask for choosing apropriate mask in run-time */\nclass MaskedDynamic extends Masked {\n  /** Currently chosen mask */\n\n  /** Compliled {@link Masked} options */\n\n  /** Chooses {@link Masked} depending on input value */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDynamic.DEFAULTS, opts));\n    this.currentMask = null;\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    super._update(opts);\n    if ('mask' in opts) {\n      // mask could be totally dynamic with only `dispatch` option\n      this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map(m => createMask(m)) : [];\n\n      // this.currentMask = this.doDispatch(''); // probably not needed but lets see\n    }\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const details = this._applyDispatch(ch, flags);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));\n    }\n    return details;\n  }\n  _applyDispatch() {\n    let appended = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;\n    const inputValue = this.rawInputValue;\n    const insertValue = flags.tail && flags._beforeTailState != null ?\n    // $FlowFixMe - tired to fight with type system\n    flags._beforeTailState._rawInputValue : inputValue;\n    const tailValue = inputValue.slice(insertValue.length);\n    const prevMask = this.currentMask;\n    const details = new ChangeDetails();\n    const prevMaskState = prevMask === null || prevMask === void 0 ? void 0 : prevMask.state;\n\n    // clone flags to prevent overwriting `_beforeTailState`\n    this.currentMask = this.doDispatch(appended, Object.assign({}, flags), tail);\n\n    // restore state after dispatch\n    if (this.currentMask) {\n      if (this.currentMask !== prevMask) {\n        // if mask changed reapply input\n        this.currentMask.reset();\n        if (insertValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          const d = this.currentMask.append(insertValue, {\n            raw: true\n          });\n          details.tailShift = d.inserted.length - prevValueBeforeTail.length;\n        }\n        if (tailValue) {\n          // $FlowFixMe - it's ok, we don't change current mask above\n          details.tailShift += this.currentMask.append(tailValue, {\n            raw: true,\n            tail: true\n          }).tailShift;\n        }\n      } else {\n        // Dispatch can do something bad with state, so\n        // restore prev mask state\n        this.currentMask.state = prevMaskState;\n      }\n    }\n    return details;\n  }\n  _appendPlaceholder() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendPlaceholder());\n    }\n    return details;\n  }\n\n  /**\n   @override\n  */\n  _appendEager() {\n    const details = this._applyDispatch(...arguments);\n    if (this.currentMask) {\n      details.aggregate(this.currentMask._appendEager());\n    }\n    return details;\n  }\n  appendTail(tail) {\n    const details = new ChangeDetails();\n    if (tail) details.aggregate(this._applyDispatch('', {}, tail));\n    return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));\n  }\n  currentMaskFlags(flags) {\n    var _flags$_beforeTailSta, _flags$_beforeTailSta2;\n    return Object.assign({}, flags, {\n      _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) === null || _flags$_beforeTailSta === void 0 ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) === null || _flags$_beforeTailSta2 === void 0 ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState\n    });\n  }\n\n  /**\n    @override\n  */\n  doDispatch(appended) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let tail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    return this.dispatch(appended, this, flags, tail);\n  }\n\n  /**\n    @override\n  */\n  doValidate(flags) {\n    return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));\n  }\n\n  /**\n    @override\n  */\n  doPrepare(str) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let [s, details] = normalizePrepare(super.doPrepare(str, flags));\n    if (this.currentMask) {\n      let currentDetails;\n      [s, currentDetails] = normalizePrepare(super.doPrepare(s, this.currentMaskFlags(flags)));\n      details = details.aggregate(currentDetails);\n    }\n    return [s, details];\n  }\n\n  /**\n    @override\n  */\n  reset() {\n    var _this$currentMask;\n    (_this$currentMask = this.currentMask) === null || _this$currentMask === void 0 ? void 0 : _this$currentMask.reset();\n    this.compiledMasks.forEach(m => m.reset());\n  }\n\n  /**\n    @override\n  */\n  get value() {\n    return this.currentMask ? this.currentMask.value : '';\n  }\n  set value(value) {\n    super.value = value;\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this.currentMask ? this.currentMask.unmaskedValue : '';\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.currentMask ? this.currentMask.typedValue : '';\n  }\n\n  // probably typedValue should not be used with dynamic\n  set typedValue(value) {\n    let unmaskedValue = String(value);\n\n    // double check it\n    if (this.currentMask) {\n      this.currentMask.typedValue = value;\n      unmaskedValue = this.currentMask.unmaskedValue;\n    }\n    this.unmaskedValue = unmaskedValue;\n  }\n  get displayValue() {\n    return this.currentMask ? this.currentMask.displayValue : '';\n  }\n\n  /**\n    @override\n  */\n  get isComplete() {\n    var _this$currentMask2;\n    return Boolean((_this$currentMask2 = this.currentMask) === null || _this$currentMask2 === void 0 ? void 0 : _this$currentMask2.isComplete);\n  }\n\n  /**\n    @override\n  */\n  get isFilled() {\n    var _this$currentMask3;\n    return Boolean((_this$currentMask3 = this.currentMask) === null || _this$currentMask3 === void 0 ? void 0 : _this$currentMask3.isFilled);\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    const details = new ChangeDetails();\n    if (this.currentMask) {\n      details.aggregate(this.currentMask.remove(...arguments))\n      // update with dispatch\n      .aggregate(this._applyDispatch());\n    }\n    return details;\n  }\n\n  /**\n    @override\n  */\n  get state() {\n    var _this$currentMask4;\n    return Object.assign({}, super.state, {\n      _rawInputValue: this.rawInputValue,\n      compiledMasks: this.compiledMasks.map(m => m.state),\n      currentMaskRef: this.currentMask,\n      currentMask: (_this$currentMask4 = this.currentMask) === null || _this$currentMask4 === void 0 ? void 0 : _this$currentMask4.state\n    });\n  }\n  set state(state) {\n    const {\n        compiledMasks,\n        currentMaskRef,\n        currentMask\n      } = state,\n      maskedState = _objectWithoutPropertiesLoose(state, _excluded);\n    this.compiledMasks.forEach((m, mi) => m.state = compiledMasks[mi]);\n    if (currentMaskRef != null) {\n      this.currentMask = currentMaskRef;\n      this.currentMask.state = currentMask;\n    }\n    super.state = maskedState;\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    return this.currentMask ? this.currentMask.extractInput(...arguments) : '';\n  }\n\n  /**\n    @override\n  */\n  extractTail() {\n    return this.currentMask ? this.currentMask.extractTail(...arguments) : super.extractTail(...arguments);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    if (this.currentMask) this.currentMask.doCommit();\n    super.doCommit();\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos() {\n    return this.currentMask ? this.currentMask.nearestInputPos(...arguments) : super.nearestInputPos(...arguments);\n  }\n  get overwrite() {\n    return this.currentMask ? this.currentMask.overwrite : super.overwrite;\n  }\n  set overwrite(overwrite) {\n    console.warn('\"overwrite\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get eager() {\n    return this.currentMask ? this.currentMask.eager : super.eager;\n  }\n  set eager(eager) {\n    console.warn('\"eager\" option is not available in dynamic mask, use this option in siblings');\n  }\n  get skipInvalid() {\n    return this.currentMask ? this.currentMask.skipInvalid : super.skipInvalid;\n  }\n  set skipInvalid(skipInvalid) {\n    if (this.isInitialized || skipInvalid !== Masked.DEFAULTS.skipInvalid) {\n      console.warn('\"skipInvalid\" option is not available in dynamic mask, use this option in siblings');\n    }\n  }\n\n  /**\n    @override\n  */\n  maskEquals(mask) {\n    return Array.isArray(mask) && this.compiledMasks.every((m, mi) => {\n      if (!mask[mi]) return;\n      const _mask$mi = mask[mi],\n        {\n          mask: oldMask\n        } = _mask$mi,\n        restOpts = _objectWithoutPropertiesLoose(_mask$mi, _excluded2);\n      return objectIncludes(m, restOpts) && m.maskEquals(oldMask);\n    });\n  }\n\n  /**\n    @override\n  */\n  typedValueEquals(value) {\n    var _this$currentMask5;\n    return Boolean((_this$currentMask5 = this.currentMask) === null || _this$currentMask5 === void 0 ? void 0 : _this$currentMask5.typedValueEquals(value));\n  }\n}\nMaskedDynamic.DEFAULTS = {\n  dispatch: (appended, masked, flags, tail) => {\n    if (!masked.compiledMasks.length) return;\n    const inputValue = masked.rawInputValue;\n\n    // simulate input\n    const inputs = masked.compiledMasks.map((m, index) => {\n      const isCurrent = masked.currentMask === m;\n      const startInputPos = isCurrent ? m.value.length : m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT);\n      if (m.rawInputValue !== inputValue) {\n        m.reset();\n        m.append(inputValue, {\n          raw: true\n        });\n      } else if (!isCurrent) {\n        m.remove(startInputPos);\n      }\n      m.append(appended, masked.currentMaskFlags(flags));\n      m.appendTail(tail);\n      return {\n        index,\n        weight: m.rawInputValue.length,\n        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.value.length, DIRECTION.FORCE_LEFT)))\n      };\n    });\n\n    // pop masks with longer values first\n    inputs.sort((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions);\n    return masked.compiledMasks[inputs[0].index];\n  }\n};\nIMask.MaskedDynamic = MaskedDynamic;\n\nexport { MaskedDynamic as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}