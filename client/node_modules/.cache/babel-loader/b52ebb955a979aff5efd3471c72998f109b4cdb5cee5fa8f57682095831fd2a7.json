{"ast":null,"code":"import MaskedPattern from './pattern.js';\nimport MaskedRange from './range.js';\nimport IMask from '../core/holder.js';\nimport '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport '../core/utils.js';\nimport '../core/change-details.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/input-definition.js';\nimport './factory.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './regexp.js';\n\n/** Date mask */\nclass MaskedDate extends MaskedPattern {\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDate.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    if (opts.mask === Date) delete opts.mask;\n    if (opts.pattern) opts.mask = opts.pattern;\n    const blocks = opts.blocks;\n    opts.blocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS());\n    // adjust year block\n    if (opts.min) opts.blocks.Y.from = opts.min.getFullYear();\n    if (opts.max) opts.blocks.Y.to = opts.max.getFullYear();\n    if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {\n      opts.blocks.m.from = opts.min.getMonth() + 1;\n      opts.blocks.m.to = opts.max.getMonth() + 1;\n      if (opts.blocks.m.from === opts.blocks.m.to) {\n        opts.blocks.d.from = opts.min.getDate();\n        opts.blocks.d.to = opts.max.getDate();\n      }\n    }\n    Object.assign(opts.blocks, this.blocks, blocks);\n\n    // add autofix\n    Object.keys(opts.blocks).forEach(bk => {\n      const b = opts.blocks[bk];\n      if (!('autofix' in b) && 'autofix' in opts) b.autofix = opts.autofix;\n    });\n    super._update(opts);\n  }\n\n  /**\n    @override\n  */\n  doValidate() {\n    const date = this.date;\n    return super.doValidate(...arguments) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n  }\n\n  /** Checks if date is exists */\n  isDateExist(str) {\n    return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n  }\n\n  /** Parsed Date */\n  get date() {\n    return this.typedValue;\n  }\n  set date(date) {\n    this.typedValue = date;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.isComplete ? super.typedValue : null;\n  }\n  set typedValue(value) {\n    super.typedValue = value;\n  }\n\n  /**\n    @override\n  */\n  maskEquals(mask) {\n    return mask === Date || super.maskEquals(mask);\n  }\n}\nMaskedDate.DEFAULTS = {\n  pattern: 'd{.}`m{.}`Y',\n  format: date => {\n    if (!date) return '';\n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n    return [day, month, year].join('.');\n  },\n  parse: str => {\n    const [day, month, year] = str.split('.');\n    return new Date(year, month - 1, day);\n  }\n};\nMaskedDate.GET_DEFAULT_BLOCKS = () => ({\n  d: {\n    mask: MaskedRange,\n    from: 1,\n    to: 31,\n    maxLength: 2\n  },\n  m: {\n    mask: MaskedRange,\n    from: 1,\n    to: 12,\n    maxLength: 2\n  },\n  Y: {\n    mask: MaskedRange,\n    from: 1900,\n    to: 9999\n  }\n});\nIMask.MaskedDate = MaskedDate;\nexport { MaskedDate as default };","map":{"version":3,"names":["MaskedPattern","MaskedRange","IMask","MaskedDate","constructor","opts","Object","assign","DEFAULTS","_update","mask","Date","pattern","blocks","GET_DEFAULT_BLOCKS","min","Y","from","getFullYear","max","to","m","getMonth","d","getDate","keys","forEach","bk","b","autofix","doValidate","date","arguments","isComplete","isDateExist","value","str","format","parse","indexOf","typedValue","maskEquals","day","String","padStart","month","year","join","split","maxLength","default"],"sources":["C:/Users/Antony/Documents/GitHub/vinki/client/node_modules/imask/esm/masked/date.js"],"sourcesContent":["import MaskedPattern from './pattern.js';\nimport MaskedRange from './range.js';\nimport IMask from '../core/holder.js';\nimport '../_rollupPluginBabelHelpers-6b3bd404.js';\nimport '../core/utils.js';\nimport '../core/change-details.js';\nimport './base.js';\nimport '../core/continuous-tail-details.js';\nimport './pattern/input-definition.js';\nimport './factory.js';\nimport './pattern/fixed-definition.js';\nimport './pattern/chunk-tail-details.js';\nimport './pattern/cursor.js';\nimport './regexp.js';\n\n/** Date mask */\nclass MaskedDate extends MaskedPattern {\n  /** Pattern mask for date according to {@link MaskedDate#format} */\n\n  /** Start date */\n\n  /** End date */\n\n  /** */\n\n  /**\n    @param {Object} opts\n  */\n  constructor(opts) {\n    super(Object.assign({}, MaskedDate.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    if (opts.mask === Date) delete opts.mask;\n    if (opts.pattern) opts.mask = opts.pattern;\n    const blocks = opts.blocks;\n    opts.blocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS());\n    // adjust year block\n    if (opts.min) opts.blocks.Y.from = opts.min.getFullYear();\n    if (opts.max) opts.blocks.Y.to = opts.max.getFullYear();\n    if (opts.min && opts.max && opts.blocks.Y.from === opts.blocks.Y.to) {\n      opts.blocks.m.from = opts.min.getMonth() + 1;\n      opts.blocks.m.to = opts.max.getMonth() + 1;\n      if (opts.blocks.m.from === opts.blocks.m.to) {\n        opts.blocks.d.from = opts.min.getDate();\n        opts.blocks.d.to = opts.max.getDate();\n      }\n    }\n    Object.assign(opts.blocks, this.blocks, blocks);\n\n    // add autofix\n    Object.keys(opts.blocks).forEach(bk => {\n      const b = opts.blocks[bk];\n      if (!('autofix' in b) && 'autofix' in opts) b.autofix = opts.autofix;\n    });\n    super._update(opts);\n  }\n\n  /**\n    @override\n  */\n  doValidate() {\n    const date = this.date;\n    return super.doValidate(...arguments) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));\n  }\n\n  /** Checks if date is exists */\n  isDateExist(str) {\n    return this.format(this.parse(str, this), this).indexOf(str) >= 0;\n  }\n\n  /** Parsed Date */\n  get date() {\n    return this.typedValue;\n  }\n  set date(date) {\n    this.typedValue = date;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.isComplete ? super.typedValue : null;\n  }\n  set typedValue(value) {\n    super.typedValue = value;\n  }\n\n  /**\n    @override\n  */\n  maskEquals(mask) {\n    return mask === Date || super.maskEquals(mask);\n  }\n}\nMaskedDate.DEFAULTS = {\n  pattern: 'd{.}`m{.}`Y',\n  format: date => {\n    if (!date) return '';\n    const day = String(date.getDate()).padStart(2, '0');\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const year = date.getFullYear();\n    return [day, month, year].join('.');\n  },\n  parse: str => {\n    const [day, month, year] = str.split('.');\n    return new Date(year, month - 1, day);\n  }\n};\nMaskedDate.GET_DEFAULT_BLOCKS = () => ({\n  d: {\n    mask: MaskedRange,\n    from: 1,\n    to: 31,\n    maxLength: 2\n  },\n  m: {\n    mask: MaskedRange,\n    from: 1,\n    to: 12,\n    maxLength: 2\n  },\n  Y: {\n    mask: MaskedRange,\n    from: 1900,\n    to: 9999\n  }\n});\nIMask.MaskedDate = MaskedDate;\n\nexport { MaskedDate as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}