{"ast":null,"code":"import { _ as _objectWithoutPropertiesLoose } from '../../_rollupPluginBabelHelpers-6b3bd404.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\nconst _excluded = [\"chunks\"];\nclass ChunksTailDetails {\n  /** */\n\n  constructor() {\n    let chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.chunks = chunks;\n    this.from = from;\n  }\n  toString() {\n    return this.chunks.map(String).join('');\n  }\n\n  // $FlowFixMe no ideas\n  extend(tailChunk) {\n    if (!String(tailChunk)) return;\n    if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n    const lastChunk = this.chunks[this.chunks.length - 1];\n    const extendLast = lastChunk && (\n    // if stops are same or tail has no stop\n    lastChunk.stop === tailChunk.stop || tailChunk.stop == null) &&\n    // if tail chunk goes just after last chunk\n    tailChunk.from === lastChunk.from + lastChunk.toString().length;\n    if (tailChunk instanceof ContinuousTailDetails) {\n      // check the ability to extend previous chunk\n      if (extendLast) {\n        // extend previous chunk\n        lastChunk.extend(tailChunk.toString());\n      } else {\n        // append new chunk\n        this.chunks.push(tailChunk);\n      }\n    } else if (tailChunk instanceof ChunksTailDetails) {\n      if (tailChunk.stop == null) {\n        // unwrap floating chunks to parent, keeping `from` pos\n        let firstTailChunk;\n        while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n          firstTailChunk = tailChunk.chunks.shift();\n          firstTailChunk.from += tailChunk.from;\n          this.extend(firstTailChunk);\n        }\n      }\n\n      // if tail chunk still has value\n      if (tailChunk.toString()) {\n        // if chunks contains stops, then popup stop to container\n        tailChunk.stop = tailChunk.blockIndex;\n        this.chunks.push(tailChunk);\n      }\n    }\n  }\n  appendTo(masked) {\n    // $FlowFixMe\n    if (!(masked instanceof IMask.MaskedPattern)) {\n      const tail = new ContinuousTailDetails(this.toString());\n      return tail.appendTo(masked);\n    }\n    const details = new ChangeDetails();\n    for (let ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n      const chunk = this.chunks[ci];\n      const lastBlockIter = masked._mapPosToBlock(masked.value.length);\n      const stop = chunk.stop;\n      let chunkBlock;\n      if (stop != null && (\n      // if block not found or stop is behind lastBlock\n      !lastBlockIter || lastBlockIter.index <= stop)) {\n        if (chunk instanceof ChunksTailDetails ||\n        // for continuous block also check if stop is exist\n        masked._stops.indexOf(stop) >= 0) {\n          const phDetails = masked._appendPlaceholder(stop);\n          details.aggregate(phDetails);\n        }\n        chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n      }\n      if (chunkBlock) {\n        const tailDetails = chunkBlock.appendTail(chunk);\n        tailDetails.skip = false; // always ignore skip, it will be set on last\n        details.aggregate(tailDetails);\n        masked._value += tailDetails.inserted;\n\n        // get not inserted chars\n        const remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n        if (remainChars) details.aggregate(masked.append(remainChars, {\n          tail: true\n        }));\n      } else {\n        details.aggregate(masked.append(chunk.toString(), {\n          tail: true\n        }));\n      }\n    }\n    return details;\n  }\n  get state() {\n    return {\n      chunks: this.chunks.map(c => c.state),\n      from: this.from,\n      stop: this.stop,\n      blockIndex: this.blockIndex\n    };\n  }\n  set state(state) {\n    const {\n        chunks\n      } = state,\n      props = _objectWithoutPropertiesLoose(state, _excluded);\n    Object.assign(this, props);\n    this.chunks = chunks.map(cstate => {\n      const chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails();\n      // $FlowFixMe already checked above\n      chunk.state = cstate;\n      return chunk;\n    });\n  }\n  unshift(beforePos) {\n    if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n    const chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n    let ci = 0;\n    while (ci < this.chunks.length) {\n      const chunk = this.chunks[ci];\n      const shiftChar = chunk.unshift(chunkShiftPos);\n      if (chunk.toString()) {\n        // chunk still contains value\n        // but not shifted - means no more available chars to shift\n        if (!shiftChar) break;\n        ++ci;\n      } else {\n        // clean if chunk has no value\n        this.chunks.splice(ci, 1);\n      }\n      if (shiftChar) return shiftChar;\n    }\n    return '';\n  }\n  shift() {\n    if (!this.chunks.length) return '';\n    let ci = this.chunks.length - 1;\n    while (0 <= ci) {\n      const chunk = this.chunks[ci];\n      const shiftChar = chunk.shift();\n      if (chunk.toString()) {\n        // chunk still contains value\n        // but not shifted - means no more available chars to shift\n        if (!shiftChar) break;\n        --ci;\n      } else {\n        // clean if chunk has no value\n        this.chunks.splice(ci, 1);\n      }\n      if (shiftChar) return shiftChar;\n    }\n    return '';\n  }\n}\nexport { ChunksTailDetails as default };","map":{"version":3,"names":["_","_objectWithoutPropertiesLoose","ChangeDetails","isString","ContinuousTailDetails","IMask","_excluded","ChunksTailDetails","constructor","chunks","arguments","length","undefined","from","toString","map","String","join","extend","tailChunk","lastChunk","extendLast","stop","push","firstTailChunk","shift","blockIndex","appendTo","masked","MaskedPattern","tail","details","ci","skip","chunk","lastBlockIter","_mapPosToBlock","value","chunkBlock","index","_stops","indexOf","phDetails","_appendPlaceholder","aggregate","_blocks","tailDetails","appendTail","_value","inserted","remainChars","slice","rawInserted","append","state","c","props","Object","assign","cstate","unshift","beforePos","chunkShiftPos","shiftChar","splice","default"],"sources":["C:/Users/Antony/Documents/GitHub/vinki/client/node_modules/imask/esm/masked/pattern/chunk-tail-details.js"],"sourcesContent":["import { _ as _objectWithoutPropertiesLoose } from '../../_rollupPluginBabelHelpers-6b3bd404.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport { isString } from '../../core/utils.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\n\nconst _excluded = [\"chunks\"];\nclass ChunksTailDetails {\n  /** */\n\n  constructor() {\n    let chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.chunks = chunks;\n    this.from = from;\n  }\n  toString() {\n    return this.chunks.map(String).join('');\n  }\n\n  // $FlowFixMe no ideas\n  extend(tailChunk) {\n    if (!String(tailChunk)) return;\n    if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n    const lastChunk = this.chunks[this.chunks.length - 1];\n    const extendLast = lastChunk && (\n    // if stops are same or tail has no stop\n    lastChunk.stop === tailChunk.stop || tailChunk.stop == null) &&\n    // if tail chunk goes just after last chunk\n    tailChunk.from === lastChunk.from + lastChunk.toString().length;\n    if (tailChunk instanceof ContinuousTailDetails) {\n      // check the ability to extend previous chunk\n      if (extendLast) {\n        // extend previous chunk\n        lastChunk.extend(tailChunk.toString());\n      } else {\n        // append new chunk\n        this.chunks.push(tailChunk);\n      }\n    } else if (tailChunk instanceof ChunksTailDetails) {\n      if (tailChunk.stop == null) {\n        // unwrap floating chunks to parent, keeping `from` pos\n        let firstTailChunk;\n        while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n          firstTailChunk = tailChunk.chunks.shift();\n          firstTailChunk.from += tailChunk.from;\n          this.extend(firstTailChunk);\n        }\n      }\n\n      // if tail chunk still has value\n      if (tailChunk.toString()) {\n        // if chunks contains stops, then popup stop to container\n        tailChunk.stop = tailChunk.blockIndex;\n        this.chunks.push(tailChunk);\n      }\n    }\n  }\n  appendTo(masked) {\n    // $FlowFixMe\n    if (!(masked instanceof IMask.MaskedPattern)) {\n      const tail = new ContinuousTailDetails(this.toString());\n      return tail.appendTo(masked);\n    }\n    const details = new ChangeDetails();\n    for (let ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n      const chunk = this.chunks[ci];\n      const lastBlockIter = masked._mapPosToBlock(masked.value.length);\n      const stop = chunk.stop;\n      let chunkBlock;\n      if (stop != null && (\n      // if block not found or stop is behind lastBlock\n      !lastBlockIter || lastBlockIter.index <= stop)) {\n        if (chunk instanceof ChunksTailDetails ||\n        // for continuous block also check if stop is exist\n        masked._stops.indexOf(stop) >= 0) {\n          const phDetails = masked._appendPlaceholder(stop);\n          details.aggregate(phDetails);\n        }\n        chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n      }\n      if (chunkBlock) {\n        const tailDetails = chunkBlock.appendTail(chunk);\n        tailDetails.skip = false; // always ignore skip, it will be set on last\n        details.aggregate(tailDetails);\n        masked._value += tailDetails.inserted;\n\n        // get not inserted chars\n        const remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n        if (remainChars) details.aggregate(masked.append(remainChars, {\n          tail: true\n        }));\n      } else {\n        details.aggregate(masked.append(chunk.toString(), {\n          tail: true\n        }));\n      }\n    }\n    return details;\n  }\n  get state() {\n    return {\n      chunks: this.chunks.map(c => c.state),\n      from: this.from,\n      stop: this.stop,\n      blockIndex: this.blockIndex\n    };\n  }\n  set state(state) {\n    const {\n        chunks\n      } = state,\n      props = _objectWithoutPropertiesLoose(state, _excluded);\n    Object.assign(this, props);\n    this.chunks = chunks.map(cstate => {\n      const chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails();\n      // $FlowFixMe already checked above\n      chunk.state = cstate;\n      return chunk;\n    });\n  }\n  unshift(beforePos) {\n    if (!this.chunks.length || beforePos != null && this.from >= beforePos) return '';\n    const chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;\n    let ci = 0;\n    while (ci < this.chunks.length) {\n      const chunk = this.chunks[ci];\n      const shiftChar = chunk.unshift(chunkShiftPos);\n      if (chunk.toString()) {\n        // chunk still contains value\n        // but not shifted - means no more available chars to shift\n        if (!shiftChar) break;\n        ++ci;\n      } else {\n        // clean if chunk has no value\n        this.chunks.splice(ci, 1);\n      }\n      if (shiftChar) return shiftChar;\n    }\n    return '';\n  }\n  shift() {\n    if (!this.chunks.length) return '';\n    let ci = this.chunks.length - 1;\n    while (0 <= ci) {\n      const chunk = this.chunks[ci];\n      const shiftChar = chunk.shift();\n      if (chunk.toString()) {\n        // chunk still contains value\n        // but not shifted - means no more available chars to shift\n        if (!shiftChar) break;\n        --ci;\n      } else {\n        // clean if chunk has no value\n        this.chunks.splice(ci, 1);\n      }\n      if (shiftChar) return shiftChar;\n    }\n    return '';\n  }\n}\n\nexport { ChunksTailDetails as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}