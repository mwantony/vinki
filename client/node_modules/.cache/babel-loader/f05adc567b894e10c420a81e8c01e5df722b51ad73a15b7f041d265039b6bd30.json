{"ast":null,"code":"import createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport '../core/utils.js';\nimport '../core/change-details.js';\n\n/** Mask pipe source and destination types */\nconst PIPE_TYPE = {\n  MASKED: 'value',\n  UNMASKED: 'unmaskedValue',\n  TYPED: 'typedValue'\n};\n\n/** Creates new pipe function depending on mask type, source and destination options */\nfunction createPipe(mask) {\n  let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PIPE_TYPE.MASKED;\n  let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PIPE_TYPE.MASKED;\n  const masked = createMask(mask);\n  return value => masked.runIsolated(m => {\n    m[from] = value;\n    return m[to];\n  });\n}\n\n/** Pipes value through mask depending on mask type, source and destination options */\nfunction pipe(value) {\n  for (var _len = arguments.length, pipeArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    pipeArgs[_key - 1] = arguments[_key];\n  }\n  return createPipe(...pipeArgs)(value);\n}\nIMask.PIPE_TYPE = PIPE_TYPE;\nIMask.createPipe = createPipe;\nIMask.pipe = pipe;\nexport { PIPE_TYPE, createPipe, pipe };","map":{"version":3,"names":["createMask","IMask","PIPE_TYPE","MASKED","UNMASKED","TYPED","createPipe","mask","from","arguments","length","undefined","to","masked","value","runIsolated","m","pipe","_len","pipeArgs","Array","_key"],"sources":["C:/Users/Antony/Documents/GitHub/vinki/client/node_modules/imask/esm/masked/pipe.js"],"sourcesContent":["import createMask from './factory.js';\nimport IMask from '../core/holder.js';\nimport '../core/utils.js';\nimport '../core/change-details.js';\n\n/** Mask pipe source and destination types */\nconst PIPE_TYPE = {\n  MASKED: 'value',\n  UNMASKED: 'unmaskedValue',\n  TYPED: 'typedValue'\n};\n\n/** Creates new pipe function depending on mask type, source and destination options */\nfunction createPipe(mask) {\n  let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PIPE_TYPE.MASKED;\n  let to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PIPE_TYPE.MASKED;\n  const masked = createMask(mask);\n  return value => masked.runIsolated(m => {\n    m[from] = value;\n    return m[to];\n  });\n}\n\n/** Pipes value through mask depending on mask type, source and destination options */\nfunction pipe(value) {\n  for (var _len = arguments.length, pipeArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    pipeArgs[_key - 1] = arguments[_key];\n  }\n  return createPipe(...pipeArgs)(value);\n}\nIMask.PIPE_TYPE = PIPE_TYPE;\nIMask.createPipe = createPipe;\nIMask.pipe = pipe;\n\nexport { PIPE_TYPE, createPipe, pipe };\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,cAAc;AACrC,OAAOC,KAAK,MAAM,mBAAmB;AACrC,OAAO,kBAAkB;AACzB,OAAO,2BAA2B;;AAElC;AACA,MAAMC,SAAS,GAAG;EAChBC,MAAM,EAAE,OAAO;EACfC,QAAQ,EAAE,eAAe;EACzBC,KAAK,EAAE;AACT,CAAC;;AAED;AACA,SAASC,UAAUA,CAACC,IAAI,EAAE;EACxB,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGP,SAAS,CAACC,MAAM;EAC/F,IAAIS,EAAE,GAAGH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAGP,SAAS,CAACC,MAAM;EAC7F,MAAMU,MAAM,GAAGb,UAAU,CAACO,IAAI,CAAC;EAC/B,OAAOO,KAAK,IAAID,MAAM,CAACE,WAAW,CAACC,CAAC,IAAI;IACtCA,CAAC,CAACR,IAAI,CAAC,GAAGM,KAAK;IACf,OAAOE,CAAC,CAACJ,EAAE,CAAC;EACd,CAAC,CAAC;AACJ;;AAEA;AACA,SAASK,IAAIA,CAACH,KAAK,EAAE;EACnB,KAAK,IAAII,IAAI,GAAGT,SAAS,CAACC,MAAM,EAAES,QAAQ,GAAG,IAAIC,KAAK,CAACF,IAAI,GAAG,CAAC,GAAGA,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEG,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGH,IAAI,EAAEG,IAAI,EAAE,EAAE;IAC9GF,QAAQ,CAACE,IAAI,GAAG,CAAC,CAAC,GAAGZ,SAAS,CAACY,IAAI,CAAC;EACtC;EACA,OAAOf,UAAU,CAAC,GAAGa,QAAQ,CAAC,CAACL,KAAK,CAAC;AACvC;AACAb,KAAK,CAACC,SAAS,GAAGA,SAAS;AAC3BD,KAAK,CAACK,UAAU,GAAGA,UAAU;AAC7BL,KAAK,CAACgB,IAAI,GAAGA,IAAI;AAEjB,SAASf,SAAS,EAAEI,UAAU,EAAEW,IAAI"},"metadata":{},"sourceType":"module","externalDependencies":[]}