{"ast":null,"code":"import { escapeRegExp, normalizePrepare, DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/**\n  Number mask\n  @param {Object} opts\n  @param {string} opts.radix - Single char\n  @param {string} opts.thousandsSeparator - Single char\n  @param {Array<string>} opts.mapToRadix - Array of single chars\n  @param {number} opts.min\n  @param {number} opts.max\n  @param {number} opts.scale - Digits after point\n  @param {boolean} opts.signed - Allow negative\n  @param {boolean} opts.normalizeZeros - Flag to remove leading and trailing zeros in the end of editing\n  @param {boolean} opts.padFractionalZeros - Flag to pad trailing zeros after point in the end of editing\n*/\nclass MaskedNumber extends Masked {\n  /** Single char */\n\n  /** Single char */\n\n  /** Array of single chars */\n\n  /** */\n\n  /** */\n\n  /** Digits after point */\n\n  /** */\n\n  /** Flag to remove leading and trailing zeros in the end of editing */\n\n  /** Flag to pad trailing zeros after point in the end of editing */\n\n  constructor(opts) {\n    super(Object.assign({}, MaskedNumber.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    super._update(opts);\n    this._updateRegExps();\n  }\n\n  /** */\n  _updateRegExps() {\n    let start = '^' + (this.allowNegative ? '[+|\\\\-]?' : '');\n    let mid = '\\\\d*';\n    let end = (this.scale ? \"(\".concat(escapeRegExp(this.radix), \"\\\\d{0,\").concat(this.scale, \"})?\") : '') + '$';\n    this._numberRegExp = new RegExp(start + mid + end);\n    this._mapToRadixRegExp = new RegExp(\"[\".concat(this.mapToRadix.map(escapeRegExp).join(''), \"]\"), 'g');\n    this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');\n  }\n\n  /** */\n  _removeThousandsSeparators(value) {\n    return value.replace(this._thousandsSeparatorRegExp, '');\n  }\n\n  /** */\n  _insertThousandsSeparators(value) {\n    // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n    const parts = value.split(this.radix);\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n    return parts.join(this.radix);\n  }\n\n  /**\n    @override\n  */\n  doPrepare(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    ch = this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (\n    /*\n      radix should be mapped when\n      1) input is done from keyboard = flags.input && flags.raw\n      2) unmasked value is set = !flags.input && !flags.raw\n      and should not be mapped when\n      1) value is set = flags.input && !flags.raw\n      2) raw value is set = !flags.input && flags.raw\n    */\n    flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch);\n    const [prepCh, details] = normalizePrepare(super.doPrepare(ch, flags));\n    if (ch && !prepCh) details.skip = true;\n    return [prepCh, details];\n  }\n\n  /** */\n  _separatorsCount(to) {\n    let extendOnSeparators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let count = 0;\n    for (let pos = 0; pos < to; ++pos) {\n      if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\n        ++count;\n        if (extendOnSeparators) to += this.thousandsSeparator.length;\n      }\n    }\n    return count;\n  }\n\n  /** */\n  _separatorsCountFromSlice() {\n    let slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._value;\n    return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let flags = arguments.length > 2 ? arguments[2] : undefined;\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.thousandsSeparator) return super._appendCharRaw(ch, flags);\n    const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\n    this._value = this._removeThousandsSeparators(this.value);\n    const appendDetails = super._appendCharRaw(ch, flags);\n    this._value = this._insertThousandsSeparators(this._value);\n    const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\n    appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\n    appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;\n    return appendDetails;\n  }\n\n  /** */\n  _findSeparatorAround(pos) {\n    if (this.thousandsSeparator) {\n      const searchFrom = pos - this.thousandsSeparator.length + 1;\n      const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\n      if (separatorPos <= pos) return separatorPos;\n    }\n    return -1;\n  }\n  _adjustRangeWithSeparators(from, to) {\n    const separatorAroundFromPos = this._findSeparatorAround(from);\n    if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\n    const separatorAroundToPos = this._findSeparatorAround(to);\n    if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\n    return [from, to];\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    const valueBeforePos = this.value.slice(0, fromPos);\n    const valueAfterPos = this.value.slice(toPos);\n    const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\n    this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\n    return new ChangeDetails({\n      tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\n    });\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos(cursorPos, direction) {\n    if (!this.thousandsSeparator) return cursorPos;\n    switch (direction) {\n      case DIRECTION.NONE:\n      case DIRECTION.LEFT:\n      case DIRECTION.FORCE_LEFT:\n        {\n          const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\n          if (separatorAtLeftPos >= 0) {\n            const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\n            if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\n              return separatorAtLeftPos;\n            }\n          }\n          break;\n        }\n      case DIRECTION.RIGHT:\n      case DIRECTION.FORCE_RIGHT:\n        {\n          const separatorAtRightPos = this._findSeparatorAround(cursorPos);\n          if (separatorAtRightPos >= 0) {\n            return separatorAtRightPos + this.thousandsSeparator.length;\n          }\n        }\n    }\n    return cursorPos;\n  }\n\n  /**\n    @override\n  */\n  doValidate(flags) {\n    // validate as string\n    let valid = Boolean(this._removeThousandsSeparators(this.value).match(this._numberRegExp));\n    if (valid) {\n      // validate as number\n      const number = this.number;\n      valid = valid && !isNaN(number) && (\n      // check min bound for negative values\n      this.min == null || this.min >= 0 || this.min <= this.number) && (\n      // check max bound for positive values\n      this.max == null || this.max <= 0 || this.number <= this.max);\n    }\n    return valid && super.doValidate(flags);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    if (this.value) {\n      const number = this.number;\n      let validnum = number;\n\n      // check bounds\n      if (this.min != null) validnum = Math.max(validnum, this.min);\n      if (this.max != null) validnum = Math.min(validnum, this.max);\n      if (validnum !== number) this.unmaskedValue = this.doFormat(validnum);\n      let formatted = this.value;\n      if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n      if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);\n      this._value = formatted;\n    }\n    super.doCommit();\n  }\n\n  /** */\n  _normalizeZeros(value) {\n    const parts = this._removeThousandsSeparators(value).split(this.radix);\n\n    // remove leading zeros\n    parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, (match, sign, zeros, num) => sign + num);\n    // add leading zero\n    if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + '0';\n    if (parts.length > 1) {\n      parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros\n      if (!parts[1].length) parts.length = 1; // remove fractional\n    }\n\n    return this._insertThousandsSeparators(parts.join(this.radix));\n  }\n\n  /** */\n  _padFractionalZeros(value) {\n    if (!value) return value;\n    const parts = value.split(this.radix);\n    if (parts.length < 2) parts.push('');\n    parts[1] = parts[1].padEnd(this.scale, '0');\n    return parts.join(this.radix);\n  }\n\n  /** */\n  doSkipInvalid(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let checkTail = arguments.length > 2 ? arguments[2] : undefined;\n    const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));\n    return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.doParse(this.unmaskedValue);\n  }\n  set typedValue(n) {\n    this.rawInputValue = this.doFormat(n).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n  }\n\n  /** Parsed Number */\n  get number() {\n    return this.typedValue;\n  }\n  set number(number) {\n    this.typedValue = number;\n  }\n\n  /**\n    Is negative allowed\n    @readonly\n  */\n  get allowNegative() {\n    return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0;\n  }\n\n  /**\n    @override\n  */\n  typedValueEquals(value) {\n    // handle  0 -> '' case (typed = 0 even if value = '')\n    // for details see https://github.com/uNmAnNeR/imaskjs/issues/134\n    return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');\n  }\n}\nMaskedNumber.UNMASKED_RADIX = '.';\nMaskedNumber.DEFAULTS = {\n  radix: ',',\n  thousandsSeparator: '',\n  mapToRadix: [MaskedNumber.UNMASKED_RADIX],\n  scale: 2,\n  signed: false,\n  normalizeZeros: true,\n  padFractionalZeros: false,\n  parse: Number,\n  format: n => n.toLocaleString('en-US', {\n    useGrouping: false,\n    maximumFractionDigits: 20\n  })\n};\nMaskedNumber.EMPTY_VALUES = [...Masked.EMPTY_VALUES, 0];\nIMask.MaskedNumber = MaskedNumber;\nexport { MaskedNumber as default };","map":{"version":3,"names":["escapeRegExp","normalizePrepare","DIRECTION","ChangeDetails","Masked","IMask","MaskedNumber","constructor","opts","Object","assign","DEFAULTS","_update","_updateRegExps","start","allowNegative","mid","end","scale","concat","radix","_numberRegExp","RegExp","_mapToRadixRegExp","mapToRadix","map","join","_thousandsSeparatorRegExp","thousandsSeparator","_removeThousandsSeparators","value","replace","_insertThousandsSeparators","parts","split","doPrepare","ch","flags","arguments","length","undefined","input","raw","prepCh","details","skip","_separatorsCount","to","extendOnSeparators","count","pos","_value","indexOf","_separatorsCountFromSlice","slice","extractInput","fromPos","toPos","_adjustRangeWithSeparators","_appendCharRaw","prevBeforeTailValue","tail","_beforeTailState","prevBeforeTailSeparatorsCount","appendDetails","beforeTailValue","beforeTailSeparatorsCount","tailShift","rawInserted","_findSeparatorAround","searchFrom","separatorPos","from","separatorAroundFromPos","separatorAroundToPos","remove","valueBeforePos","valueAfterPos","nearestInputPos","cursorPos","direction","NONE","LEFT","FORCE_LEFT","separatorAtLeftPos","separatorAtLeftEndPos","RIGHT","FORCE_RIGHT","separatorAtRightPos","doValidate","valid","Boolean","match","number","isNaN","min","max","doCommit","validnum","Math","unmaskedValue","doFormat","formatted","normalizeZeros","_normalizeZeros","padFractionalZeros","_padFractionalZeros","sign","zeros","num","test","push","padEnd","doSkipInvalid","checkTail","dropFractional","UNMASKED_RADIX","includes","typedValue","doParse","n","rawInputValue","signed","typedValueEquals","EMPTY_VALUES","parse","Number","format","toLocaleString","useGrouping","maximumFractionDigits","default"],"sources":["C:/Users/Antony/Documents/GitHub/vinki/client/node_modules/imask/esm/masked/number.js"],"sourcesContent":["import { escapeRegExp, normalizePrepare, DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport Masked from './base.js';\nimport IMask from '../core/holder.js';\nimport '../core/continuous-tail-details.js';\n\n/**\n  Number mask\n  @param {Object} opts\n  @param {string} opts.radix - Single char\n  @param {string} opts.thousandsSeparator - Single char\n  @param {Array<string>} opts.mapToRadix - Array of single chars\n  @param {number} opts.min\n  @param {number} opts.max\n  @param {number} opts.scale - Digits after point\n  @param {boolean} opts.signed - Allow negative\n  @param {boolean} opts.normalizeZeros - Flag to remove leading and trailing zeros in the end of editing\n  @param {boolean} opts.padFractionalZeros - Flag to pad trailing zeros after point in the end of editing\n*/\nclass MaskedNumber extends Masked {\n  /** Single char */\n\n  /** Single char */\n\n  /** Array of single chars */\n\n  /** */\n\n  /** */\n\n  /** Digits after point */\n\n  /** */\n\n  /** Flag to remove leading and trailing zeros in the end of editing */\n\n  /** Flag to pad trailing zeros after point in the end of editing */\n\n  constructor(opts) {\n    super(Object.assign({}, MaskedNumber.DEFAULTS, opts));\n  }\n\n  /**\n    @override\n  */\n  _update(opts) {\n    super._update(opts);\n    this._updateRegExps();\n  }\n\n  /** */\n  _updateRegExps() {\n    let start = '^' + (this.allowNegative ? '[+|\\\\-]?' : '');\n    let mid = '\\\\d*';\n    let end = (this.scale ? \"(\".concat(escapeRegExp(this.radix), \"\\\\d{0,\").concat(this.scale, \"})?\") : '') + '$';\n    this._numberRegExp = new RegExp(start + mid + end);\n    this._mapToRadixRegExp = new RegExp(\"[\".concat(this.mapToRadix.map(escapeRegExp).join(''), \"]\"), 'g');\n    this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), 'g');\n  }\n\n  /** */\n  _removeThousandsSeparators(value) {\n    return value.replace(this._thousandsSeparatorRegExp, '');\n  }\n\n  /** */\n  _insertThousandsSeparators(value) {\n    // https://stackoverflow.com/questions/2901102/how-to-print-a-number-with-commas-as-thousands-separators-in-javascript\n    const parts = value.split(this.radix);\n    parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, this.thousandsSeparator);\n    return parts.join(this.radix);\n  }\n\n  /**\n    @override\n  */\n  doPrepare(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    ch = this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (\n    /*\n      radix should be mapped when\n      1) input is done from keyboard = flags.input && flags.raw\n      2) unmasked value is set = !flags.input && !flags.raw\n      and should not be mapped when\n      1) value is set = flags.input && !flags.raw\n      2) raw value is set = !flags.input && flags.raw\n    */\n    flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch);\n    const [prepCh, details] = normalizePrepare(super.doPrepare(ch, flags));\n    if (ch && !prepCh) details.skip = true;\n    return [prepCh, details];\n  }\n\n  /** */\n  _separatorsCount(to) {\n    let extendOnSeparators = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let count = 0;\n    for (let pos = 0; pos < to; ++pos) {\n      if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {\n        ++count;\n        if (extendOnSeparators) to += this.thousandsSeparator.length;\n      }\n    }\n    return count;\n  }\n\n  /** */\n  _separatorsCountFromSlice() {\n    let slice = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._value;\n    return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);\n  }\n\n  /**\n    @override\n  */\n  extractInput() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    let flags = arguments.length > 2 ? arguments[2] : undefined;\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));\n  }\n\n  /**\n    @override\n  */\n  _appendCharRaw(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.thousandsSeparator) return super._appendCharRaw(ch, flags);\n    const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);\n    this._value = this._removeThousandsSeparators(this.value);\n    const appendDetails = super._appendCharRaw(ch, flags);\n    this._value = this._insertThousandsSeparators(this._value);\n    const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);\n    appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;\n    appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;\n    return appendDetails;\n  }\n\n  /** */\n  _findSeparatorAround(pos) {\n    if (this.thousandsSeparator) {\n      const searchFrom = pos - this.thousandsSeparator.length + 1;\n      const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);\n      if (separatorPos <= pos) return separatorPos;\n    }\n    return -1;\n  }\n  _adjustRangeWithSeparators(from, to) {\n    const separatorAroundFromPos = this._findSeparatorAround(from);\n    if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;\n    const separatorAroundToPos = this._findSeparatorAround(to);\n    if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;\n    return [from, to];\n  }\n\n  /**\n    @override\n  */\n  remove() {\n    let fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n    [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);\n    const valueBeforePos = this.value.slice(0, fromPos);\n    const valueAfterPos = this.value.slice(toPos);\n    const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);\n    this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));\n    const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);\n    return new ChangeDetails({\n      tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length\n    });\n  }\n\n  /**\n    @override\n  */\n  nearestInputPos(cursorPos, direction) {\n    if (!this.thousandsSeparator) return cursorPos;\n    switch (direction) {\n      case DIRECTION.NONE:\n      case DIRECTION.LEFT:\n      case DIRECTION.FORCE_LEFT:\n        {\n          const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);\n          if (separatorAtLeftPos >= 0) {\n            const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;\n            if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) {\n              return separatorAtLeftPos;\n            }\n          }\n          break;\n        }\n      case DIRECTION.RIGHT:\n      case DIRECTION.FORCE_RIGHT:\n        {\n          const separatorAtRightPos = this._findSeparatorAround(cursorPos);\n          if (separatorAtRightPos >= 0) {\n            return separatorAtRightPos + this.thousandsSeparator.length;\n          }\n        }\n    }\n    return cursorPos;\n  }\n\n  /**\n    @override\n  */\n  doValidate(flags) {\n    // validate as string\n    let valid = Boolean(this._removeThousandsSeparators(this.value).match(this._numberRegExp));\n    if (valid) {\n      // validate as number\n      const number = this.number;\n      valid = valid && !isNaN(number) && (\n      // check min bound for negative values\n      this.min == null || this.min >= 0 || this.min <= this.number) && (\n      // check max bound for positive values\n      this.max == null || this.max <= 0 || this.number <= this.max);\n    }\n    return valid && super.doValidate(flags);\n  }\n\n  /**\n    @override\n  */\n  doCommit() {\n    if (this.value) {\n      const number = this.number;\n      let validnum = number;\n\n      // check bounds\n      if (this.min != null) validnum = Math.max(validnum, this.min);\n      if (this.max != null) validnum = Math.min(validnum, this.max);\n      if (validnum !== number) this.unmaskedValue = this.doFormat(validnum);\n      let formatted = this.value;\n      if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);\n      if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);\n      this._value = formatted;\n    }\n    super.doCommit();\n  }\n\n  /** */\n  _normalizeZeros(value) {\n    const parts = this._removeThousandsSeparators(value).split(this.radix);\n\n    // remove leading zeros\n    parts[0] = parts[0].replace(/^(\\D*)(0*)(\\d*)/, (match, sign, zeros, num) => sign + num);\n    // add leading zero\n    if (value.length && !/\\d$/.test(parts[0])) parts[0] = parts[0] + '0';\n    if (parts.length > 1) {\n      parts[1] = parts[1].replace(/0*$/, ''); // remove trailing zeros\n      if (!parts[1].length) parts.length = 1; // remove fractional\n    }\n\n    return this._insertThousandsSeparators(parts.join(this.radix));\n  }\n\n  /** */\n  _padFractionalZeros(value) {\n    if (!value) return value;\n    const parts = value.split(this.radix);\n    if (parts.length < 2) parts.push('');\n    parts[1] = parts[1].padEnd(this.scale, '0');\n    return parts.join(this.radix);\n  }\n\n  /** */\n  doSkipInvalid(ch) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let checkTail = arguments.length > 2 ? arguments[2] : undefined;\n    const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));\n    return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;\n  }\n\n  /**\n    @override\n  */\n  get unmaskedValue() {\n    return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);\n  }\n  set unmaskedValue(unmaskedValue) {\n    super.unmaskedValue = unmaskedValue;\n  }\n\n  /**\n    @override\n  */\n  get typedValue() {\n    return this.doParse(this.unmaskedValue);\n  }\n  set typedValue(n) {\n    this.rawInputValue = this.doFormat(n).replace(MaskedNumber.UNMASKED_RADIX, this.radix);\n  }\n\n  /** Parsed Number */\n  get number() {\n    return this.typedValue;\n  }\n  set number(number) {\n    this.typedValue = number;\n  }\n\n  /**\n    Is negative allowed\n    @readonly\n  */\n  get allowNegative() {\n    return this.signed || this.min != null && this.min < 0 || this.max != null && this.max < 0;\n  }\n\n  /**\n    @override\n  */\n  typedValueEquals(value) {\n    // handle  0 -> '' case (typed = 0 even if value = '')\n    // for details see https://github.com/uNmAnNeR/imaskjs/issues/134\n    return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === '');\n  }\n}\nMaskedNumber.UNMASKED_RADIX = '.';\nMaskedNumber.DEFAULTS = {\n  radix: ',',\n  thousandsSeparator: '',\n  mapToRadix: [MaskedNumber.UNMASKED_RADIX],\n  scale: 2,\n  signed: false,\n  normalizeZeros: true,\n  padFractionalZeros: false,\n  parse: Number,\n  format: n => n.toLocaleString('en-US', {\n    useGrouping: false,\n    maximumFractionDigits: 20\n  })\n};\nMaskedNumber.EMPTY_VALUES = [...Masked.EMPTY_VALUES, 0];\nIMask.MaskedNumber = MaskedNumber;\n\nexport { MaskedNumber as default };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}